<script>
const loadingText = document.querySelector("#loading-text");
let loadedBytes = 0;
const DB_NAME = "gameFilesDB";
const STORE_NAME = "files";

// Open or create IndexedDB
function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME);
            }
        };
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
    });
}

async function saveFile(name, buffer) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        try {
            store.put(buffer, name);
            tx.oncomplete = () => resolve();
            tx.onerror = e => {
                console.error(`Storage Error for ${name}:`, e.target.error);
                reject(e.target.error);
            };
        } catch (err) {
            console.error("Critical Storage Error:", err);
            reject(err);
        }
    });
}

async function getFile(name) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(name);
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
    });
}

async function fetchWithCache(name, url) {
    try {
        let cached = await getFile(name);
        if (cached) {
            console.log(`Loaded from cache: ${name}`);
            // Update UI for cached items
            loadedBytes += cached.byteLength;
            updateUI();
            return cached;
        }

        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status} - ${url}`);
        
        const reader = response.body.getReader();
        let chunks = [];
        let received = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            received += value.length;
            loadedBytes += value.length;
            chunks.push(value);
            updateUI();
        }

        let fullBuffer = new Uint8Array(received);
        let offset = 0;
        for (let chunk of chunks) {
            fullBuffer.set(chunk, offset);
            offset += chunk.length;
        }

        await saveFile(name, fullBuffer.buffer);
        return fullBuffer.buffer;
    } catch (err) {
        console.error(`Fetch failed for ${name}:`, err);
        loadingText.textContent = "ERROR LOADING DATA. Check Console (F12).";
        throw err;
    }
}

function updateUI() {
    let mbDone = (loadedBytes / (1024 * 1024)).toFixed(2);
    let mbTotal = '633.45';
    loadingText.textContent = `LOADING... ${mbDone} MB / ${mbTotal} MB`;
}

async function mergeFiles(fileParts, namePrefix) {
    const buffers = [];
    for (let i = 0; i < fileParts.length; i++) {
        const buffer = await fetchWithCache(`${namePrefix}.part${i+1}`, fileParts[i]);
        buffers.push(buffer);
    }
    const mergedBlob = new Blob(buffers);
    return URL.createObjectURL(mergedBlob);
}

function getParts(file, start, end) {
    let parts = [];
    for (let i = start; i <= end; i++) {
        parts.push(file + ".part" + i);
    }
    return parts;
}

// Start execution
(async () => {
    try {
        const urls = await Promise.all([
            mergeFiles(getParts("index.data", 1, 7), "index.data"),
            mergeFiles(getParts("audio/emotion.adf", 1, 3), "emotion.adf"),
            mergeFiles(getParts("audio/espant.adf", 1, 3), "espant.adf"),
            mergeFiles(getParts("audio/fever.adf", 1, 3), "fever.adf"),
            mergeFiles(getParts("audio/flash.adf", 1, 3), "flash.adf"),
            mergeFiles(getParts("audio/kchat.adf", 1, 3), "kchat.adf"),
            mergeFiles(getParts("audio/vcpr.adf", 1, 2), "vcpr.adf"),
            mergeFiles(getParts("audio/vrock.adf", 1, 4), "vrock.adf"),
            mergeFiles(getParts("audio/wave.adf", 1, 4), "wave.adf"),
            mergeFiles(getParts("audio/wild.adf", 1, 4), "wild.adf"),
        ]);

        const [indexdataurl, EMOTIONadfurl, ESPANTadfurl, FEVERadfurl, FLASHadfurl, KCHATadfurl, VCPRadfurl, VROCKadfurl, WAVEadfurl, WILDadfurl] = urls;

        // Override fetch
        const originalFetch = window.fetch;
        window.fetch = async function(input, init) {
            let urlString = input instanceof Request ? input.url : String(input);
            let lowerUrl = urlString.toLowerCase();

            if (lowerUrl.includes("index.data")) input = indexdataurl;
            else if (lowerUrl.includes("emotion.adf")) input = EMOTIONadfurl;
            else if (lowerUrl.includes("espant.adf")) input = ESPANTadfurl;
            else if (lowerUrl.includes("fever.adf")) input = FEVERadfurl;
            else if (lowerUrl.includes("flash.adf")) input = FLASHadfurl;
            else if (lowerUrl.includes("kchat.adf")) input = KCHATadfurl;
            else if (lowerUrl.includes("vcpr.adf")) input = VCPRadfurl;
            else if (lowerUrl.includes("vrock.adf")) input = VROCKadfurl;
            else if (lowerUrl.includes("wave.adf")) input = WAVEadfurl;
            else if (lowerUrl.includes("wild.adf")) input = WILDadfurl;

            // FIX: Don't lowercase blob URLs
            let finalInput = (typeof input === 'string' && input.startsWith('blob:')) ? input : (typeof input === 'string' ? input.toLowerCase() : input);
            return originalFetch(finalInput, init);
        };

        // Override XHR
        const originalOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, ...rest) {
            let lowerUrl = url.toLowerCase();
            if (lowerUrl.includes("https://cdn.dos.zone/vcsky/fetched/")) url = url.replace("https://cdn.dos.zone/vcsky/fetched/", "");
            
            if (lowerUrl.includes("index.data")) url = indexdataurl;
            else if (lowerUrl.includes("emotion.adf")) url = EMOTIONadfurl;
            else if (lowerUrl.includes("espant.adf")) url = ESPANTadfurl;
            else if (lowerUrl.includes("fever.adf")) url = FEVERadfurl;
            else if (lowerUrl.includes("flash.adf")) url = FLASHadfurl;
            else if (lowerUrl.includes("kchat.adf")) url = KCHATadfurl;
            else if (lowerUrl.includes("vcpr.adf")) url = VCPRadfurl;
            else if (lowerUrl.includes("vrock.adf")) url = VROCKadfurl;
            else if (lowerUrl.includes("wave.adf")) url = WAVEadfurl;
            else if (lowerUrl.includes("wild.adf")) url = WILDadfurl;

            // FIX: Don't lowercase if it's a blob
            let finalUrl = url.startsWith('blob:') ? url : url.toLowerCase();
            return originalOpen.call(this, method, finalUrl, ...rest);
        };

        // Load game scripts
        ["gamepademulator.js", "idbfs.js", "game.js"].forEach(src => {
            const script = document.createElement("script");
            script.src = src;
            document.body.appendChild(script);
        });

        loadingText.remove();
    } catch (error) {
        console.error("Initialization failed:", error);
    }
})();
</script>
